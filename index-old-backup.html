<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SUPERSIDER GLOBALLY</title>
    <style>
        body {
            margin: 0;
            background: #000000;
            color: #86F5AF;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
        }
        
        /* Loading screen overlay */
        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000000;
            z-index: 9999;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 1;
            transition: opacity 1.5s ease-out;
            pointer-events: none;
        }
        
        #loadingScreen.fade-out {
            opacity: 0;
        }
        
        #globeViz {
            width: 100vw;
            height: 100vh;
            opacity: 0;
            transition: opacity 2s ease-in;
        }
        
        #globeViz.fade-in {
            opacity: 1;
        }
        
        /* Ensure globe canvas also starts transparent */
        #globeViz canvas {
            opacity: inherit;
        }
        
        /* Fade-in animations for UI elements */
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }
        
        .info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(26, 48, 47, 0.9);
            padding: 12px;
            border-radius: 6px;
            max-width: 240px;
            z-index: 100;
            color: white;
            opacity: 0;
            animation: fadeInUp 1s ease-out forwards;
            animation-delay: 4s;
        }
        
        .info-panel h2 {
            margin-top: 0;
            color: #86F5AF;
        }
        
        .country-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(26, 48, 47, 0.9);
            padding: 8px;
            border-radius: 6px;
            max-width: 280px;
            max-height: 85vh;
            overflow: hidden;
            z-index: 100;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            opacity: 0;
            animation: fadeInUp 1s ease-out forwards;
            animation-delay: 4.3s;
        }
        
        .country-panel.collapsed {
            max-height: 45px;
            overflow: hidden;
        }
        
        .country-panel h3 {
            margin: 0;
            color: #86F5AF;
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            justify-content: space-between;
            transition: color 0.3s ease;
            font-size: 12px;
            padding: 4px 0;
        }
        
        .country-panel h3:hover {
            color: #DAFF87;
        }
        
        .collapse-arrow {
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            font-size: 14px;
        }
        
        .country-panel.collapsed .collapse-arrow {
            transform: rotate(-90deg);
        }
        
        .category-panel {
            position: absolute;
            top: 20px;
            right: 320px;
            background: rgba(26, 48, 47, 0.9);
            padding: 8px;
            border-radius: 6px;
            max-width: 280px;
            max-height: 85vh;
            overflow-y: auto;
            z-index: 100;
            opacity: 0;
            animation: fadeInUp 1s ease-out forwards;
            animation-delay: 4.6s;
        }
        
        .category-panel h3 {
            margin: 0 0 8px 0;
            color: #86F5AF;
            font-size: 12px;
        }
        
        .category-item {
            display: flex;
            align-items: center;
            margin: 6px 0;
            padding: 8px 10px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            user-select: none;
            font-size: 11px;
            border: 2px solid transparent;
            line-height: 1.2;
            min-height: 36px;
        }
        
        .category-item:hover {
            background: rgba(134, 245, 175, 0.15);
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(134, 245, 175, 0.2);
        }
        
        .category-item.active {
            background: #86F5AF !important;
            color: #1A302F;
            border-color: #DAFF87;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(134, 245, 175, 0.4);
        }
        
        .category-question {
            font-size: 11px;
            flex-grow: 1;
            font-weight: 500;
            line-height: 1.2;
        }
        
        .category-count {
            font-size: 10px;
            color: #86F5AF;
            margin-left: 6px;
            font-weight: bold;
            background: rgba(134, 245, 175, 0.2);
            padding: 2px 5px;
            border-radius: 8px;
            min-width: 18px;
            text-align: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .category-item.active .category-count {
            color: #1A302F;
            background: rgba(26, 48, 47, 0.3);
            opacity: 1;
        }
        
        .country-content {
            transition: opacity 0.3s ease, transform 0.3s ease;
            transform: translateY(0);
            opacity: 1;
        }
        
        .country-panel.collapsed .country-content {
            opacity: 0;
            transform: translateY(-10px);
            pointer-events: none;
        }
        
        .country-controls {
            margin-bottom: 8px;
        }
        
        .country-controls button {
            background: #86F5AF;
            color: #1A302F;
            border: none;
            padding: 3px 6px;
            margin: 1px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
            font-weight: bold;
        }
        
        .country-controls button:hover {
            background: #DAFF87;
        }
        
        .country-list {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2px;
            max-height: none;
        }
        
        .country-item {
            display: flex;
            align-items: center;
            margin: 1px 0;
            padding: 3px 5px;
            border-radius: 3px;
            cursor: pointer;
            transition: background-color 0.2s ease;
            user-select: none;
            font-size: 9px;
        }
        
        .country-item:hover {
            background: rgba(134, 245, 175, 0.2);
        }
        
        .country-item.selected {
            background: #86F5AF !important;
            color: #1A302F;
        }
        
        .country-item.selected .country-count {
            color: #1A302F;
        }
        
        .country-name {
            font-size: 9px;
            flex-grow: 1;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .country-count {
            font-size: 8px;
            color: #86F5AF;
            margin-left: 3px;
            font-weight: bold;
        }
        
        .country-info-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            background: rgba(26, 48, 47, 0.95);
            border: 2px solid #86F5AF;
            border-radius: 10px;
            padding: 20px;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 0 20px rgba(134, 245, 175, 0.5);
            min-width: 300px;
            text-align: center;
        }
        
        .country-info-overlay.show {
            opacity: 1;
            visibility: visible;
            transform: translate(-50%, -50%) scale(1);
        }
        
        .country-info-title {
            font-size: 24px;
            color: #86F5AF;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 10px;
        }
        
        .country-info-count {
            font-size: 18px;
            color: #DAFF87;
            margin-bottom: 15px;
        }
        
        .supersiders-text {
            font-size: 14px;
            color: #DAFF87;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .close-info {
            position: absolute;
            top: 10px;
            right: 15px;
            background: none;
            border: none;
            color: white;
            font-size: 20px;
            cursor: pointer;
            transition: color 0.3s ease;
        }
        
        .close-info:hover {
            color: #DAFF87;
        }
        
        /* Custom tooltip styles */
        .custom-tooltip {
            position: fixed !important;
            background: rgba(26, 48, 47, 0.98) !important;
            border: 2px solid #86F5AF !important;
            border-radius: 8px;
            padding: 12px 16px;
            color: white !important;
            font-size: 13px;
            white-space: nowrap;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.6) !important;
            max-width: 300px;
            z-index: 99999 !important;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease, transform 0.3s ease;
            display: none;
            transform: translateY(-5px);
            will-change: transform, opacity;
        }
        
        /* Tooltip disabled during loading */
        .custom-tooltip.loading-disabled {
            pointer-events: none !important;
            display: none !important;
        }
        
        .custom-tooltip.show {
            opacity: 1 !important;
            display: block !important;
            visibility: visible !important;
            transform: translateY(0);
        }
        
        .tooltip-name {
            color: #86F5AF;
            font-weight: bold;
            font-size: 14px;
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .tooltip-count {
            color: #DAFF87;
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 2px;
        }
        
        .tooltip-coords {
            color: rgba(134, 245, 175, 0.7);
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
    </style>
    <script src="//cdn.jsdelivr.net/npm/globe.gl"></script>
    <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
    </script>
</head>

<body>
    <!-- Loading screen overlay -->
    <div id="loadingScreen"></div>
    
    <div id="globeViz"></div>
    
    <div class="info-panel">
        <h2>SUPERSIDER GLOBALLY</h2>
        <p>Total countries: <span id="country-count">0</span></p>
        <p>Supersiders selected: <span id="total-count">0</span></p>
        <p><em>Click on points to see details</em></p>
    </div>
    
    <div class="category-panel">
        <h3>Explore Questions</h3>
        <div class="category-list" id="categoryList">
            <!-- Categories will be populated here -->
        </div>
    </div>
    
    <div class="country-panel collapsed" id="countryPanel">
        <h3 onclick="toggleCountryPanel()">
            Countries 
            <span class="collapse-arrow" id="collapseArrow">▼</span>
        </h3>
        <div class="country-content" id="countryContent">
            <div class="country-controls">
                <button onclick="selectAllCountries()">Select All</button>
                <button onclick="deselectAllCountries()">Deselect All</button>
            </div>
            <div class="country-list" id="countryList">
                <!-- Countries will be populated here -->
            </div>
        </div>
    </div>

    <!-- Country Info Overlay -->
    <div class="country-info-overlay" id="countryInfoOverlay">
        <button class="close-info" onclick="hideCountryInfo()">×</button>
        <div class="country-info-title" id="countryInfoTitle">COUNTRY NAME</div>
        <div class="country-info-count" id="countryInfoCount">000</div>
        <div class="supersiders-text">SUPERSIDERS</div>
    </div>

    <!-- Custom Tooltip -->
    <div class="custom-tooltip loading-disabled" id="customTooltip">
        <div class="tooltip-name" id="tooltipName">COUNTRY NAME</div>
        <div class="tooltip-count" id="tooltipCount">000 SUPERSIDERS</div>
        <div class="tooltip-coords" id="tooltipCoords">Lat: 0.00°, Lng: 0.00°</div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        
        // Make THREE available globally
        window.THREE = THREE;
        
        // Your country data
        const countryData = [
            { name: "Argentina", count: 86, coordinates: { lat: -34.6037, lng: -58.3816 } },
            { name: "Armenia", count: 3, coordinates: { lat: 40.1792, lng: 44.4991 } },
            { name: "Australia", count: 1, coordinates: { lat: -25.2744, lng: 133.7751 } },
            { name: "Belarus", count: 1, coordinates: { lat: 53.7098, lng: 27.9534 } },
            { name: "Bosnia & Herzegovina", count: 4, coordinates: { lat: 43.9159, lng: 17.6791 } },
            { name: "Brazil", count: 82, coordinates: { lat: -14.2350, lng: -51.9253 } },
            { name: "Bulgaria", count: 1, coordinates: { lat: 42.7339, lng: 25.4858 } },
            { name: "Canada", count: 16, coordinates: { lat: 56.1304, lng: -106.3468 } },
            { name: "Colombia", count: 67, coordinates: { lat: 4.5709, lng: -74.2973 } },
            { name: "Costa Rica", count: 15, coordinates: { lat: 9.7489, lng: -83.7534 } },
            { name: "Croatia", count: 1, coordinates: { lat: 45.1000, lng: 15.2000 } },
            { name: "Cyprus", count: 1, coordinates: { lat: 35.1264, lng: 33.4299 } },
            { name: "Czech Republic", count: 1, coordinates: { lat: 49.8175, lng: 15.4730 } },
            { name: "Denmark", count: 1, coordinates: { lat: 56.2639, lng: 9.5018 } },
            { name: "Dominican Republic", count: 6, coordinates: { lat: 18.7357, lng: -70.1627 } },
            { name: "Ecuador", count: 5, coordinates: { lat: -1.8312, lng: -78.1834 } },
            { name: "Egypt", count: 3, coordinates: { lat: 26.0975, lng: 31.2357 } },
            { name: "El Salvador", count: 7, coordinates: { lat: 13.7942, lng: -88.8965 } },
            { name: "France", count: 3, coordinates: { lat: 46.6034, lng: 1.8883 } },
            { name: "Georgia", count: 1, coordinates: { lat: 42.3154, lng: 43.3569 } },
            { name: "Germany", count: 8, coordinates: { lat: 51.1657, lng: 10.4515 } },
            { name: "Ghana", count: 1, coordinates: { lat: 7.9465, lng: -1.0232 } },
            { name: "Greece", count: 6, coordinates: { lat: 39.0742, lng: 21.8243 } },
            { name: "Guatemala", count: 4, coordinates: { lat: 15.7835, lng: -90.2308 } },
            { name: "Honduras", count: 1, coordinates: { lat: 15.2000, lng: -86.2419 } },
            { name: "Hungary", count: 5, coordinates: { lat: 47.1625, lng: 19.5033 } },
            { name: "India", count: 8, coordinates: { lat: 20.5937, lng: 78.9629 } },
            { name: "Indonesia", count: 8, coordinates: { lat: -0.7893, lng: 113.9213 } },
            { name: "Ireland", count: 1, coordinates: { lat: 53.4129, lng: -8.2439 } },
            { name: "Italy", count: 7, coordinates: { lat: 41.8719, lng: 12.5674 } },
            { name: "Jordan", count: 1, coordinates: { lat: 30.5852, lng: 36.2384 } },
            { name: "Kenya", count: 1, coordinates: { lat: -0.0236, lng: 37.9062 } },
            { name: "Latvia", count: 1, coordinates: { lat: 56.8796, lng: 24.6032 } },
            { name: "Lebanon", count: 2, coordinates: { lat: 33.8547, lng: 35.8623 } },
            { name: "Libya", count: 2, coordinates: { lat: 26.3351, lng: 17.2283 } },
            { name: "Lithuania", count: 3, coordinates: { lat: 55.1694, lng: 23.8813 } },
            { name: "Malaysia", count: 3, coordinates: { lat: 4.2105, lng: 101.9758 } },
            { name: "Mauritius", count: 1, coordinates: { lat: -20.3484, lng: 57.5522 } },
            { name: "Mexico", count: 39, coordinates: { lat: 23.6345, lng: -102.5528 } },
            { name: "Netherlands", count: 4, coordinates: { lat: 52.1326, lng: 5.2913 } },
            { name: "Nicaragua", count: 3, coordinates: { lat: 12.2650, lng: -85.2072 } },
            { name: "Nigeria", count: 1, coordinates: { lat: 9.0820, lng: 8.6753 } },
            { name: "North Macedonia", count: 2, coordinates: { lat: 41.6086, lng: 21.7453 } },
            { name: "Norway", count: 7, coordinates: { lat: 60.4720, lng: 8.4689 } },
            { name: "Palestine", count: 1, coordinates: { lat: 31.9522, lng: 35.2332 } },
            { name: "Panama", count: 7, coordinates: { lat: 8.5380, lng: -80.7821 } },
            { name: "Paraguay", count: 1, coordinates: { lat: -23.4425, lng: -58.4438 } },
            { name: "Peru", count: 9, coordinates: { lat: -9.1900, lng: -75.0152 } },
            { name: "Philippines", count: 8, coordinates: { lat: 12.8797, lng: 121.7740 } },
            { name: "Poland", count: 13, coordinates: { lat: 51.9194, lng: 19.1451 } },
            { name: "Portugal", count: 40, coordinates: { lat: 39.3999, lng: -8.2245 } },
            { name: "Romania", count: 7, coordinates: { lat: 45.9432, lng: 24.9668 } },
            { name: "Russian Federation", count: 2, coordinates: { lat: 61.5240, lng: 105.3188 } },
            { name: "Serbia", count: 8, coordinates: { lat: 44.0165, lng: 21.0059 } },
            { name: "Slovenia", count: 1, coordinates: { lat: 46.1512, lng: 14.9955 } },
            { name: "South Africa", count: 139, coordinates: { lat: -30.5595, lng: 22.9375 } },
            { name: "Spain", count: 39, coordinates: { lat: 40.4637, lng: -3.7492 } },
            { name: "Sweden", count: 1, coordinates: { lat: 60.1282, lng: 18.6435 } },
            { name: "Thailand", count: 1, coordinates: { lat: 15.8700, lng: 100.9925 } },
            { name: "Tunisia", count: 2, coordinates: { lat: 33.8869, lng: 9.5375 } },
            { name: "Turkey", count: 2, coordinates: { lat: 38.9637, lng: 35.2433 } },
            { name: "Ukraine", count: 4, coordinates: { lat: 48.3794, lng: 31.1656 } },
            { name: "United Arab Emirates", count: 5, coordinates: { lat: 23.4241, lng: 53.8478 } },
            { name: "United Kingdom", count: 12, coordinates: { lat: 55.3781, lng: -3.4360 } },
            { name: "United States of America (USA)", count: 18, coordinates: { lat: 37.0902, lng: -95.7129 } },
            { name: "Uruguay", count: 9, coordinates: { lat: -32.5228, lng: -55.7658 } },
            { name: "Venezuela", count: 4, coordinates: { lat: 6.4238, lng: -66.5897 } }
        ];

        // Track which countries are enabled
        let enabledCountries = new Set(countryData.map(country => country.name));
        
        // Track active category
        let activeCategory = null;
        
        // Define regional categories with questions
        const categories = {
            'lone_wolf': {
                question: 'Are there lone wolf countries at Superside?',
                countries: countryData.filter(country => country.count === 1).map(country => country.name)
            },
            'latin_america': {
                question: 'How strong is Superside\'s presence in Latin America?',
                countries: ['Argentina', 'Brazil', 'Colombia', 'Costa Rica', 'Dominican Republic', 'Ecuador', 'El Salvador', 'Guatemala', 'Honduras', 'Mexico', 'Nicaragua', 'Panama', 'Paraguay', 'Peru', 'Uruguay', 'Venezuela']
            },
            'europe': {
                question: 'Which European countries have Supersiders?',
                countries: ['Armenia', 'Belarus', 'Bosnia & Herzegovina', 'Bulgaria', 'Croatia', 'Cyprus', 'Czech Republic', 'Denmark', 'France', 'Georgia', 'Germany', 'Greece', 'Hungary', 'Ireland', 'Italy', 'Latvia', 'Lithuania', 'Netherlands', 'North Macedonia', 'Norway', 'Poland', 'Portugal', 'Romania', 'Russian Federation', 'Serbia', 'Slovenia', 'Spain', 'Sweden', 'Turkey', 'Ukraine', 'United Kingdom']
            },
            'africa': {
                question: 'Is Superside expanding across Africa?',
                countries: ['Egypt', 'Ghana', 'Kenya', 'Libya', 'Mauritius', 'Nigeria', 'South Africa', 'Tunisia']
            }
        };
        
        // Initialize the globe variable
        let myGlobe;
        let astronautModel;

        // Toggle country panel collapse/expand
        function toggleCountryPanel() {
            const panel = document.getElementById('countryPanel');
            const arrow = document.getElementById('collapseArrow');
            
            panel.classList.toggle('collapsed');
            
            // Update arrow rotation
            if (panel.classList.contains('collapsed')) {
                arrow.style.transform = 'rotate(-90deg)';
            } else {
                arrow.style.transform = 'rotate(0deg)';
            }
        }

        // Initialize collapsed state
        function initializeUI() {
            const arrow = document.getElementById('collapseArrow');
            // Set initial arrow state for collapsed panel
            arrow.style.transform = 'rotate(-90deg)';
        }

        // Airplane flight animation control
        let airplaneFlightInterval = null;

        // Function to animate category selection and zoom to region
        function animateCategorySelection(categoryId, countryNames) {
            console.log('Category selected:', categoryId, 'with countries:', countryNames);
            
            // Stop any existing airplane flight animation
            if (airplaneFlightInterval) {
                clearInterval(airplaneFlightInterval);
                airplaneFlightInterval = null;
            }
            
            // Special airplane flight animation for lone wolf mode
            if (categoryId === 'lone_wolf') {
                console.log('Starting airplane flight animation around the world!');
                startAirplaneFlight();
                return;
            }
            
            // Define region views for each category
            const regionViews = {
                'latin_america': {
                    lat: -15,      // Center of South America
                    lng: -60,      // Center longitude for South America
                    altitude: 2.2  // Zoomed out view
                },
                'europe': {
                    lat: 54,       // Center of Europe
                    lng: 15,       // Center longitude for Europe
                    altitude: 1.8  // Closer view for Europe (smaller region)
                },
                'africa': {
                    lat: 0,        // Center of Africa
                    lng: 20,       // Center longitude for Africa
                    altitude: 2.0  // Medium zoom for Africa
                }
            };
            
            // Get the appropriate view for this category
            const targetView = regionViews[categoryId];
            if (targetView) {
                console.log(`Zooming to ${categoryId} region:`, targetView);
                myGlobe.pointOfView(targetView, 2500); // 2.5 second smooth transition
            }
        }

        // Simulate an airplane flying around the world
        function startAirplaneFlight() {
            // Get all lone wolf countries for the flight path
            const loneWolfCountries = countryData.filter(c => c.count === 1);
            
            let currentIndex = 0;
            let flightPhase = 0; // 0: approach, 1: flyby, 2: depart
            const msPerFrame = 50; // 20 fps for smooth animation
            
            // Start with initial position
            if (loneWolfCountries.length > 0) {
                const firstCountry = loneWolfCountries[0];
                myGlobe.pointOfView({
                    lat: firstCountry.coordinates.lat,
                    lng: firstCountry.coordinates.lng - 30, // Start 30 degrees to the west
                    altitude: 1.5
                }, 0);
            }
            
            airplaneFlightInterval = setInterval(() => {
                if (loneWolfCountries.length === 0) return;
                
                const currentCountry = loneWolfCountries[currentIndex];
                const nextCountry = loneWolfCountries[(currentIndex + 1) % loneWolfCountries.length];
                
                const currentPOV = myGlobe.pointOfView();
                
                if (flightPhase === 0) {
                    // APPROACH: Fly towards the country with slight altitude variation
                    const targetLat = currentCountry.coordinates.lat + (Math.random() - 0.5) * 5;
                    const targetLng = currentCountry.coordinates.lng;
                    const targetAlt = 1.2 + Math.sin(Date.now() * 0.001) * 0.3; // Gentle altitude bobbing
                    
                    myGlobe.pointOfView({
                        lat: currentPOV.lat + (targetLat - currentPOV.lat) * 0.15,
                        lng: currentPOV.lng + (targetLng - currentPOV.lng) * 0.15,
                        altitude: currentPOV.altitude + (targetAlt - currentPOV.altitude) * 0.1
                    }, msPerFrame);
                    
                    // Check if close enough to move to flyby
                    const latDiff = Math.abs(currentPOV.lat - targetLat);
                    const lngDiff = Math.abs(currentPOV.lng - targetLng);
                    if (latDiff < 3 && lngDiff < 3) {
                        flightPhase = 1;
                    }
                    
                } else if (flightPhase === 1) {
                    // FLYBY: Pass over the country with banking motion
                    const flybyLat = currentCountry.coordinates.lat + Math.sin(Date.now() * 0.003) * 3;
                    const flybyLng = currentCountry.coordinates.lng + 5; // Pass slightly east
                    const flybyAlt = 1.0 + Math.cos(Date.now() * 0.002) * 0.2; // Banking effect
                    
                    myGlobe.pointOfView({
                        lat: flybyLat,
                        lng: flybyLng,
                        altitude: flybyAlt
                    }, msPerFrame);
                    
                    flightPhase = 2;
                    
                } else {
                    // DEPART: Fly away towards next country
                    const departureLat = currentCountry.coordinates.lat + (nextCountry.coordinates.lat - currentCountry.coordinates.lat) * 0.3;
                    const departureLng = currentCountry.coordinates.lng + (nextCountry.coordinates.lng - currentCountry.coordinates.lng) * 0.3;
                    const departureAlt = 1.8 + Math.sin(Date.now() * 0.0015) * 0.4; // Climb and vary
                    
                    myGlobe.pointOfView({
                        lat: currentPOV.lat + (departureLat - currentPOV.lat) * 0.12,
                        lng: currentPOV.lng + (departureLng - currentPOV.lng) * 0.12,
                        altitude: currentPOV.altitude + (departureAlt - currentPOV.altitude) * 0.08
                    }, msPerFrame);
                    
                    // Check if far enough to move to next country
                    const distToNext = Math.sqrt(
                        Math.pow(currentPOV.lat - nextCountry.coordinates.lat, 2) +
                        Math.pow(currentPOV.lng - nextCountry.coordinates.lng, 2)
                    );
                    
                    if (distToNext < 20) {
                        currentIndex = (currentIndex + 1) % loneWolfCountries.length;
                        flightPhase = 0;
                    }
                }
            }, msPerFrame);
        }

        // Function to get color based on count
        function getPointColor(count) {
            if (count >= 50) return '#DAFF87'; // High count - Bright Green
            if (count >= 10) return '#86F5AF'; // Medium count - Medium Green
            return '#4A9B5E'; // Low count - Dark Green
        }

        // Function to get point size based on count
        function getPointSize(count) {
            if (count >= 50) return 0.8;
            if (count >= 10) return 0.5;
            return 0.3;
        }

        // Function to calculate distance between two points
        function calculateDistance(lat1, lng1, lat2, lng2) {
            const R = 6371; // Earth's radius in kilometers
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLng = (lng2 - lng1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLng/2) * Math.sin(dLng/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        // Function to detect if a route should go across the Pacific
        function isTransPacificRoute(startLng, endLng, startLat, endLat) {
            // Define regions
            const isLatinAmerica = (lng) => lng >= -120 && lng <= -30; // Western hemisphere, Americas
            const isAsia = (lng) => lng >= 95 && lng <= 180; // Eastern Asia/Pacific
            const isOceania = (lng) => lng >= 110 && lng <= 180 && endLat >= -50 && endLat <= -10; // Australia/NZ area
            
            // Check if this is a Latin America to Asia/Oceania route
            const fromLatAm = isLatinAmerica(startLng);
            const toAsiaPacific = isAsia(endLng) || isOceania(endLng);
            const fromAsiaPacific = isAsia(startLng) || isOceania(startLng);
            const toLatAm = isLatinAmerica(endLng);
            
            return (fromLatAm && toAsiaPacific) || (fromAsiaPacific && toLatAm);
        }

        // Generate connections between countries
        function generateConnections(enabledCountriesSet = enabledCountries) {
            const connections = [];
            
            // Filter countries to only enabled ones
            const activeCountries = countryData.filter(country => enabledCountriesSet.has(country.name));
            
            // Check if we're in Lone Wolf mode
            const isLoneWolfMode = activeCategory === 'lone_wolf';
            
            // Ensure every country gets at least one connection (especially lone wolves)
            const countryConnections = new Map();
            activeCountries.forEach(country => countryConnections.set(country.name, 0));
            
            // Connect ALL enabled countries to each other with varying probability
            for (let i = 0; i < activeCountries.length; i++) {
                for (let j = i + 1; j < activeCountries.length; j++) {
                    const country1 = activeCountries[i];
                    const country2 = activeCountries[j];
                    
                    const distance = calculateDistance(
                        country1.coordinates.lat, country1.coordinates.lng,
                        country2.coordinates.lat, country2.coordinates.lng
                    );
                    
                    // Create multiple seeds for more variety in connections
                    const seed1 = (country1.name + country2.name).split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
                    const seed2 = (country2.name + country1.name).split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
                    const seed3 = Math.abs(country1.coordinates.lat * country2.coordinates.lng);
                    const combinedSeed = (seed1 + seed2 + seed3) % 10000;
                    
                    const pseudoRandom = Math.sin(combinedSeed * 0.001) * 10000;
                    const randomValue = Math.abs(pseudoRandom - Math.floor(pseudoRandom));
                    
                    // SUPER OPTIMIZED: Half as many lines as before
                    let probability = 0.02; // REDUCED 50% from 0.04 to 0.02
                    
                    // Special handling for Lone Wolf mode or lone wolf countries
                    if (isLoneWolfMode || (country1.count === 1 || country2.count === 1)) {
                        // Give lone wolves better chances to connect
                        probability = 0.08; // REDUCED 50% from 0.15 to 0.08
                        
                        // Boost probability if either country has no connections yet
                        if (countryConnections.get(country1.name) === 0 || countryConnections.get(country2.name) === 0) {
                            probability = 0.15; // REDUCED 50% from 0.30 to 0.15
                        }
                    } else {
                        // Varied probability for non-lone wolves
                        const countFactor = Math.min((country1.count + country2.count) / 300, 0.05); // REDUCED 50%
                        const distanceFactor = Math.max(0.015, 1 - (distance / 15000)); // REDUCED 50%
                        const randomFactor = Math.random() * 0.03; // REDUCED 50%
                        
                        probability = 0.015 + countFactor + (distanceFactor * 0.025) + randomFactor; // REDUCED 50%
                        
                        // Boost for countries with few connections
                        if (countryConnections.get(country1.name) < 2 || countryConnections.get(country2.name) < 2) {
                            probability += 0.05; // REDUCED 50% from 0.10
                        }
                        
                        // Ensure probability stays within bounds
                        probability = Math.min(Math.max(probability, 0.015), 0.125); // REDUCED 50%
                    }
                    
                    // Add time-based variation for more dynamic connections
                    const timeVariation = Math.sin(Date.now() * 0.0001 + combinedSeed) * 0.015; // REDUCED 50%
                    probability += timeVariation;
                    
                    const shouldConnect = randomValue < probability;
                    
                    if (shouldConnect) {
                        // Check if this should be a trans-Pacific route
                        const isTransPacific = isTransPacificRoute(
                            country1.coordinates.lng, country2.coordinates.lng, 
                            country1.coordinates.lat, country2.coordinates.lat
                        );
                        
                        let startLng = country1.coordinates.lng;
                        let endLng = country2.coordinates.lng;
                        
                        // Force trans-Pacific routes to go across the Pacific
                        if (isTransPacific) {
                            // If crossing from Americas to Asia, ensure we go the Pacific way
                            if (startLng < 0 && endLng > 0) {
                                // From Americas (negative lng) to Asia (positive lng) - go east across Pacific
                                if (Math.abs(endLng - startLng) > 180) {
                                    startLng = startLng < -150 ? startLng : startLng - 360;
                                }
                            } else if (startLng > 0 && endLng < 0) {
                                // From Asia (positive lng) to Americas (negative lng) - go west across Pacific
                                if (Math.abs(startLng - endLng) > 180) {
                                    endLng = endLng < -150 ? endLng : endLng - 360;
                                }
                            }
                        }
                        
                        connections.push({
                            startLat: country1.coordinates.lat,
                            startLng: startLng,
                            endLat: country2.coordinates.lat,
                            endLng: endLng,
                            startCountry: country1.name,
                            endCountry: country2.name,
                            startCount: country1.count,
                            endCount: country2.count,
                            distance: distance
                        });
                        
                        // Track connections for each country
                        countryConnections.set(country1.name, countryConnections.get(country1.name) + 1);
                        countryConnections.set(country2.name, countryConnections.get(country2.name) + 1);
                    }
                }
            }
            
            // Ensure isolated countries (especially lone wolves) get at least one connection
            const isolatedCountries = activeCountries.filter(country => countryConnections.get(country.name) === 0);
            isolatedCountries.forEach(isolatedCountry => {
                // Find a random partner for isolated countries
                const potentialPartners = activeCountries.filter(country => country.name !== isolatedCountry.name);
                if (potentialPartners.length > 0) {
                    const randomIndex = Math.floor(Math.random() * potentialPartners.length);
                    const partner = potentialPartners[randomIndex];
                    
                    connections.push({
                        startLat: isolatedCountry.coordinates.lat,
                        startLng: isolatedCountry.coordinates.lng,
                        endLat: partner.coordinates.lat,
                        endLng: partner.coordinates.lng,
                        startCountry: isolatedCountry.name,
                        endCountry: partner.name,
                        startCount: isolatedCountry.count,
                        endCount: partner.count,
                        distance: calculateDistance(
                            isolatedCountry.coordinates.lat, isolatedCountry.coordinates.lng,
                            partner.coordinates.lat, partner.coordinates.lng
                        )
                    });
                }
            });
            
            console.log(`Generated ${connections.length} connections for ${activeCountries.length} countries`);
            console.log(`Isolated countries that got forced connections: ${isolatedCountries.length}`);
            return connections;
        }

        // Generate the connections
        let connections = generateConnections();

        // Functions to show/hide country info overlay
        function showCountryInfo(country) {
            const overlay = document.getElementById('countryInfoOverlay');
            const title = document.getElementById('countryInfoTitle');
            const count = document.getElementById('countryInfoCount');
            
            title.textContent = country.name.toUpperCase();
            count.textContent = country.count.toString();
            
            overlay.classList.add('show');
            
            // Auto-hide after 2 seconds (reduced from 4)
            setTimeout(() => {
                hideCountryInfo();
            }, 2000);
        }
        
        function hideCountryInfo() {
            const overlay = document.getElementById('countryInfoOverlay');
            overlay.classList.remove('show');
        }
        
        // Make hideCountryInfo global for onclick handler
        window.hideCountryInfo = hideCountryInfo;

        // Functions for category panel management
        function populateCategoryList() {
            const categoryList = document.getElementById('categoryList');
            categoryList.innerHTML = '';
            
            Object.entries(categories).forEach(([categoryId, categoryData]) => {
                const categoryItem = document.createElement('div');
                categoryItem.className = 'category-item';
                
                // Add active class if this category is currently active
                if (activeCategory === categoryId) {
                    categoryItem.classList.add('active');
                }
                
                // Click handler for the entire item
                categoryItem.addEventListener('click', (e) => {
                    // Deactivate other categories
                    document.querySelectorAll('.category-item').forEach(item => {
                        item.classList.remove('active');
                    });
                    
                    if (activeCategory === categoryId) {
                        // If clicking the same category, deactivate it
                        activeCategory = null;
                    } else {
                        // Activate this category
                        activeCategory = categoryId;
                        categoryItem.classList.add('active');
                        
                        // Select only countries from this category
                        const validCountries = categoryData.countries.filter(countryName => 
                            countryData.some(country => country.name === countryName)
                        );
                        enabledCountries = new Set(validCountries);
                        
                        // Animate category selection with region zoom
                        animateCategorySelection(categoryId, validCountries);
                    }
                    
                    populateCategoryList();
                    populateCountryList();
                    updateVisualization();
                });
                
                const questionSpan = document.createElement('span');
                questionSpan.className = 'category-question';
                questionSpan.textContent = categoryData.question;
                
                const countSpan = document.createElement('span');
                countSpan.className = 'category-count';
                const validCountries = categoryData.countries.filter(countryName => 
                    countryData.some(country => country.name === countryName)
                );
                countSpan.textContent = validCountries.length;
                
                categoryItem.appendChild(questionSpan);
                categoryItem.appendChild(countSpan);
                
                categoryList.appendChild(categoryItem);
            });
        }

        // Functions for country panel management
        function populateCountryList() {
            const countryList = document.getElementById('countryList');
            countryList.innerHTML = '';
            
            // Sort countries by count (descending)
            const sortedCountries = [...countryData].sort((a, b) => b.count - a.count);
            
            sortedCountries.forEach(country => {
                const countryItem = document.createElement('div');
                countryItem.className = 'country-item';
                
                // Add selected class if country is enabled
                if (enabledCountries.has(country.name)) {
                    countryItem.classList.add('selected');
                }
                
                // Click handler for the entire item
                countryItem.addEventListener('click', (e) => {
                    // Deactivate any active category when manually selecting countries
                    if (activeCategory) {
                        activeCategory = null;
                        populateCategoryList();
                    }
                    
                    if (enabledCountries.has(country.name)) {
                        enabledCountries.delete(country.name);
                        countryItem.classList.remove('selected');
                    } else {
                        enabledCountries.add(country.name);
                        countryItem.classList.add('selected');
                        
                        // Show country info overlay
                        showCountryInfo(country);
                        
                        // Focus on the country with smooth zoom
                        myGlobe.pointOfView({
                            lat: country.coordinates.lat,
                            lng: country.coordinates.lng,
                            altitude: 1.2
                        }, 2000);
                    }
                    
                    // Auto-update is always enabled now
                    updateVisualization();
                });
                
                const nameSpan = document.createElement('span');
                nameSpan.className = 'country-name';
                nameSpan.textContent = country.name;
                
                const countSpan = document.createElement('span');
                countSpan.className = 'country-count';
                countSpan.textContent = `(${country.count})`;
                
                countryItem.appendChild(nameSpan);
                countryItem.appendChild(countSpan);
                
                countryList.appendChild(countryItem);
            });
        }
        
        function selectAllCountries() {
            activeCategory = null;
            enabledCountries = new Set(countryData.map(country => country.name));
            populateCategoryList();
            populateCountryList();
            // Auto-update is always enabled now
            updateVisualization();
        }
        
        function deselectAllCountries() {
            activeCategory = null;
            enabledCountries = new Set();
            populateCategoryList();
            populateCountryList();
            // Auto-update is always enabled now
            updateVisualization();
        }
        
        function updateVisualization() {
            // Filter countries and generate new connections
            const enabledCountryData = countryData.filter(country => enabledCountries.has(country.name));
            connections = generateConnections();
            
            // Update globe data
            myGlobe.pointsData(enabledCountryData);
            myGlobe.arcsData(connections);
            
            // Update info panel
            updateInfoPanel();
            
            console.log(`Updated visualization: ${enabledCountryData.length} countries, activeCategory: ${activeCategory}`);
            
            // Handle lone-wolf astronaut orbiters: clear existing and add for selected lone wolves
            try {
                // Clear current orbiters first
                clearOrbiters();

                if (activeCategory === 'lone_wolf') {
                    const loneWolfCountries = enabledCountryData.filter(c => c.count === 1);
                    console.log('Lone wolf mode active! Found', loneWolfCountries.length, 'lone wolf countries:', loneWolfCountries.map(c => c.name));
                    
                    // Add an astronaut orbiting each lone-wolf country currently enabled
                    loneWolfCountries.forEach(c => {
                        console.log('Attempting to add astronaut for:', c.name);
                        addOrbitingAstronaut(c);
                    });
                    
                    console.log('Total astronauts in scene:', astronautOrbiters.size);
                }
            } catch (e) {
                console.error('Error managing astronaut orbiters:', e, e.stack);
            }
        }
        
        function updateInfoPanel() {
            const enabledCountryData = countryData.filter(country => enabledCountries.has(country.name));
            document.getElementById('country-count').textContent = enabledCountryData.length;
            document.getElementById('total-count').textContent = enabledCountryData.reduce((sum, country) => sum + country.count, 0);
        }

        // Global arc opacity multiplier for fade-in animation
        let arcOpacityMultiplier = 0.001; // Start almost invisible

        // Function to get arc color based on connection strength
        function getArcColor(connection) {
            const avgCount = (connection.startCount + connection.endCount) / 2;
            const baseOpacity = Math.min(0.3, avgCount / 200); // Reduced opacity significantly
            const opacity = baseOpacity * arcOpacityMultiplier; // Apply fade-in multiplier
            
            // Always return array with opacity applied
            if (avgCount >= 50) return [`rgba(218, 255, 135, ${opacity})`, `rgba(218, 255, 135, ${opacity * 1.5})`]; // Bright Green
            if (avgCount >= 20) return [`rgba(134, 245, 175, ${opacity})`, `rgba(134, 245, 175, ${opacity * 1.5})`]; // Medium Green
            return [`rgba(74, 155, 94, ${opacity})`, `rgba(74, 155, 94, ${opacity * 1.5})`]; // Dark Green
        }

        // Initialize the globe
        myGlobe = new Globe(document.getElementById('globeViz'))
            .globeImageUrl('https://upload.wikimedia.org/wikipedia/commons/b/b3/Solarsystemscope_texture_8k_earth_nightmap.jpg')
            .backgroundImageUrl('//cdn.jsdelivr.net/npm/three-globe/example/img/night-sky.png')
            .pointOfView({ lat: 20, lng: 0, altitude: 2.5 })
            
            // Points configuration - START WITH EMPTY DATA (will animate in later)
            .pointsData([])
            .pointLat(d => d.coordinates.lat)
            .pointLng(d => d.coordinates.lng)
            .pointColor(d => getPointColor(d.count))
            .pointAltitude(d => getPointSize(d.count) * 0.2) // Cylinder height
            .pointRadius(d => getPointSize(d.count) * 0.8) // REDUCED from 1.2 to 0.8 - smaller = less polygons
            .pointResolution(8) // ADDED: Lower resolution cylinders (default is higher) = fewer polygons
            .pointLabel(d => null) // Disable built-in tooltip completely
            .pointsMerge(false) // Keep false for individual point detection
            .pointsTransitionDuration(1500) // Longer smooth animation for bars to grow
            
            // Arcs configuration - START WITH EMPTY DATA (will animate in later)
            .arcsData([])
            .arcStartLat(d => d.startLat)
            .arcStartLng(d => d.startLng)
            .arcEndLat(d => d.endLat)
            .arcEndLng(d => d.endLng)
            .arcColor(d => getArcColor(d))
            .arcAltitude(d => {
                // Calculate dynamic altitude based on distance to ensure arcs always go around the outside
                const distance = d.distance;
                
                // Special handling for trans-Pacific routes (Latin America to Asia)
                const isTransPacific = isTransPacificRoute(d.startLng, d.endLng, d.startLat, d.endLat);
                if (isTransPacific) {
                    return 0.3; // High arc for trans-Pacific routes
                }
                
                // For long distances (like Germany-Argentina), use higher altitude
                // For short distances, use lower altitude
                if (distance > 10000) return 0.4; // Very long distances - high arc
                if (distance > 5000) return 0.25;  // Long distances - medium arc
                if (distance > 2000) return 0.15;  // Medium distances - low-medium arc
                return 0.08; // Short distances - low arc
            })
            .arcCurveResolution(32) // REDUCED from 64 to 32 for better performance
            .arcCircularResolution(3) // REDUCED from 6 to 3 for better performance
            .arcStroke(0.1) // REDUCED from 0.2 to 0.1 - thinner lines = better performance
            .arcDashLength(0.25)
            .arcDashGap(1)
            .arcDashInitialGap(() => Math.random())
            .arcDashAnimateTime(0) // Start with NO animation (will be enabled later)
            .arcsTransitionDuration(1500) // Longer transition for smooth arc growth
            
            .enablePointerInteraction(true);
        
        // Store reference to enable arc animation later
        window.myGlobeRef = myGlobe;

        // Removed pulsing animation - bars are now fixed height

        // --- Astronaut orbiters for lone-wolf countries ---
        // Map to keep track of orbiters per country name
        const astronautOrbiters = new Map();

        // Template creator for a tiny astronaut mesh (very small scale for orbiting cylinders)
        function createAstronautTemplate() {
            console.log('Creating astronaut template...');
            
            // THREE should be available from window
            if (!window.THREE) {
                console.error('THREE not available!');
                return null;
            }

            const group = new THREE.Group();

            const whiteMat = new THREE.MeshStandardMaterial({ color: 0xEEEEEE, metalness: 0.3, roughness: 0.7 });
            const visorMat = new THREE.MeshStandardMaterial({ color: 0x1A5F7A, metalness: 0.9, roughness: 0.1, transparent: true, opacity: 0.6 });

            // Simple helmet
            const helmet = new THREE.Mesh(new THREE.SphereGeometry(0.5, 8, 8), whiteMat);
            helmet.position.y = 0.6;
            group.add(helmet);

            // Visor (slightly inset)
            const visor = new THREE.Mesh(new THREE.SphereGeometry(0.45, 8, 8), visorMat);
            visor.position.set(0, 0.6, 0.15);
            group.add(visor);

            // Tiny body
            const body = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.3, 0.8, 6), whiteMat);
            body.position.y = -0.3;
            group.add(body);

            // Tiny backpack
            const pack = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.5, 0.15), new THREE.MeshStandardMaterial({ color: 0xFF6B35 }));
            pack.position.set(0, -0.1, -0.2);
            group.add(pack);

            // Make larger and visible
            group.scale.set(1.5, 1.5, 1.5);

            console.log('Astronaut template created:', group);
            return group;
        }

        // Convert lat/lng to Cartesian coordinates - EXACT same convention as three-globe
        function latLngToCartesian(lat, lng, radius) {
            // three-globe uses this exact conversion:
            // phi = latitude in radians, theta = longitude in radians
            const phi = (lat) * Math.PI / 180; // latitude: -90 to +90
            const theta = (lng) * Math.PI / 180; // longitude: -180 to +180
            
            // Standard spherical to cartesian with three-globe's coordinate system
            const x = radius * Math.cos(phi) * Math.sin(theta);
            const y = radius * Math.sin(phi);
            const z = radius * Math.cos(phi) * Math.cos(theta);

            return { x, y, z };
        }

        // Add an orbiting astronaut for a country point object (from countryData)
        function addOrbitingAstronaut(country) {
            console.log('Adding orbiting astronaut for:', country.name);
            
            if (!myGlobe || !country || !country.name) {
                console.warn('Missing globe or country:', { myGlobe, country });
                return;
            }

            // Avoid duplicate
            if (astronautOrbiters.has(country.name)) {
                console.log('Astronaut already exists for:', country.name);
                return;
            }

            if (!window.THREE) {
                console.error('THREE not available for astronaut creation!');
                return;
            }

            // Determine globe radius (fallback to 100)
            let R = 100;
            try {
                if (typeof myGlobe.globeRadius === 'function') R = myGlobe.globeRadius();
                else if (typeof myGlobe.getGlobeRadius === 'function') R = myGlobe.getGlobeRadius();
            } catch (e) {
                console.warn('Could not get globe radius, using default 100');
            }

            // Calculate cylinder dimensions - SAME as globe.gl uses for points
            const altFrac = getPointSize(country.count) * 0.2; // same formula as .pointAltitude
            const cylinderHeight = R * altFrac; // height of the cylinder
            
            // Position at MIDDLE of cylinder (where the cylinder base starts at R and extends outward)
            const midCylinderRadius = R + (cylinderHeight / 2);
            
            console.log('Country:', country.name, 'R:', R, 'altFrac:', altFrac, 'cylinderHeight:', cylinderHeight, 'midRadius:', midCylinderRadius);

            // Get the base position on globe surface
            const lat = country.coordinates.lat;
            const lng = country.coordinates.lng;
            
            // Calculate the surface normal vector using SAME convention as latLngToCartesian
            const phi = lat * Math.PI / 180;
            const theta = lng * Math.PI / 180;
            
            // Normal vector pointing away from center (same as unit position vector)
            const normalX = Math.cos(phi) * Math.sin(theta);
            const normalY = Math.sin(phi);
            const normalZ = Math.cos(phi) * Math.cos(theta);
            
            const normal = new THREE.Vector3(normalX, normalY, normalZ);
            
            // Position at middle of cylinder
            const cylinderMidPos = normal.clone().multiplyScalar(midCylinderRadius);
            
            // Create pivot at the cylinder's CENTER (not top)
            const pivot = new THREE.Object3D();
            pivot.position.copy(cylinderMidPos);
            
            // Orient the pivot so its local Y axis aligns with the cylinder axis (normal to surface)
            // This makes rotation around Z axis orbit around the cylinder
            pivot.lookAt(0, 0, 0); // Look at globe center
            pivot.rotateX(-Math.PI / 2); // Rotate so Y points away from center
            
            // Create astronaut
            const astronaut = createAstronautTemplate();
            if (!astronaut) {
                console.error('Failed to create astronaut template');
                return;
            }
            
            // Position astronaut to orbit around the cylinder
            // In local space: Z axis will orbit around Y (cylinder) axis
            const orbitRadius = 2.5; // Small orbit radius around cylinder
            astronaut.position.set(0, 0, orbitRadius); // offset in Z = orbits around Y

            // Add astronaut under pivot
            pivot.add(astronaut);

            // Add pivot to scene
            const scene = myGlobe.scene();
            if (!scene) {
                console.error('Could not access globe scene');
                return;
            }
            scene.add(pivot);

            console.log('Astronaut added to scene at position:', pivot.position, 'for country:', country.name);

            // Store
            astronautOrbiters.set(country.name, { 
                pivot, 
                astronaut, 
                orbitRadius, 
                speed: 1.0 + Math.random() * 0.5,
                country: country.name,
                normal: normal // Store for reference
            });
        }

        // Remove all current orbiters
        function clearOrbiters() {
            console.log('Clearing', astronautOrbiters.size, 'orbiters');
            const scene = myGlobe.scene();
            astronautOrbiters.forEach(({ pivot, country }) => {
                if (scene && pivot) {
                    scene.remove(pivot);
                    console.log('Removed astronaut for:', country);
                }
            });
            astronautOrbiters.clear();
        }

        // Update / animate orbiters (call inside render loop)
        function updateOrbiters() {
            if (astronautOrbiters.size === 0) return;
            
            const time = Date.now() * 0.001;
            astronautOrbiters.forEach((data, name) => {
                const { pivot, astronaut, speed, orbitRadius } = data;
                if (pivot && astronaut) {
                    // Rotate around Y axis (cylinder axis) to orbit around the cylinder
                    pivot.rotation.y = time * speed;
                    
                    // Optional: small bobbing animation (moves along cylinder axis)
                    astronaut.position.y = Math.sin(time * 3 * speed) * 0.3;
                }
            });
        }

        // Hook orbiters update into the main animation loop used by globe.gl
        // globe.gl exposes a renderer and does its own animate loop; use requestAnimationFrame
        (function orbitersLoop() {
            updateOrbiters();
            requestAnimationFrame(orbitersLoop);
        })();
        
        console.log('Astronaut orbiter system initialized');

        // === ELEGANT LOADING SEQUENCE ===
        // Step 1: Start with black screen (already set via CSS)
        const loadingScreen = document.getElementById('loadingScreen');
        const globeViz = document.getElementById('globeViz');
        
        // Step 2: After a brief moment, fade out loading screen (reveals starry background)
        setTimeout(() => {
            console.log('Step 1: Fading out black screen, revealing stars...');
            loadingScreen.classList.add('fade-out');
        }, 500);
        
        // Step 3: After loading screen fades, start fading in the globe
        setTimeout(() => {
            console.log('Step 2: Fading in Earth globe...');
            globeViz.classList.add('fade-in');
            // Remove loading screen from DOM after transition
            setTimeout(() => {
                loadingScreen.style.display = 'none';
            }, 1500);
        }, 2000);
        
        // Step 3.5: Grow cylinders and arcs AFTER Earth is visible (at 3.5s)
        setTimeout(() => {
            console.log('Step 2.5: Growing cylinders (points) and connections (arcs)...');
            // Add the data to make cylinders and arcs grow with animation
            const enabledCountryData = countryData.filter(country => enabledCountries.has(country.name));
            myGlobe.pointsData(enabledCountryData);
            myGlobe.arcsData(connections);
            
            // Animate arc opacity from 0 to 1 over 2 seconds (fade-in)
            const fadeInDuration = 2000; // 2 seconds
            const fadeInStart = Date.now();
            
            function animateArcFadeIn() {
                const elapsed = Date.now() - fadeInStart;
                const progress = Math.min(elapsed / fadeInDuration, 1);
                
                // Linear fade for more noticeable effect
                arcOpacityMultiplier = progress;
                
                console.log('Arc fade progress:', progress.toFixed(2), 'opacity:', arcOpacityMultiplier.toFixed(2));
                
                // Force update by re-setting the color function
                myGlobe.arcColor(getArcColor);
                
                if (progress < 1) {
                    requestAnimationFrame(animateArcFadeIn);
                } else {
                    console.log('Arc fade-in complete, starting dash animation...');
                    // Enable dash animation after fade-in is complete
                    myGlobe.arcDashAnimateTime(3000);
                    // Trigger re-render to start animation
                    const currentData = myGlobe.arcsData();
                    myGlobe.arcsData([]);
                    setTimeout(() => myGlobe.arcsData(currentData), 10);
                }
            }
            
            animateArcFadeIn();
        }, 3500);
        
        // Step 4: UI panels will fade in automatically via CSS animations (at 4s, 4.3s, 4.6s)
        setTimeout(() => {
            console.log('Step 3: UI panels fading in...');
        }, 4000);
        
        // Step 5: Enable tooltip AFTER everything is loaded (at 6s - after arcs fade in)
        setTimeout(() => {
            console.log('Step 4: Enabling interactive tooltip...');
            const tooltip = document.getElementById('customTooltip');
            tooltip.classList.remove('loading-disabled');
        }, 6000);

        // Initialize the interface
        populateCategoryList();
        populateCountryList();
        updateInfoPanel();
        initializeUI();

        // Test THREE availability and astronaut system after a short delay
        setTimeout(() => {
            console.log('=== ASTRONAUT SYSTEM TEST ===');
            console.log('THREE available:', typeof window.THREE !== 'undefined');
            console.log('Globe scene available:', myGlobe && myGlobe.scene());
            console.log('Active category:', activeCategory);
            
            if (typeof window.THREE === 'undefined') {
                console.error('THREE is not available! This is the problem.');
            } else {
                console.log('THREE is available, version check:', window.THREE.REVISION);
            }
            
            // Try to create a test astronaut template
            try {
                const testAstro = createAstronautTemplate();
                console.log('Test astronaut created successfully:', testAstro);
            } catch (e) {
                console.error('Failed to create test astronaut:', e);
            }
        }, 2000);

        // Make functions global for onclick handlers
        window.selectAllCountries = selectAllCountries;
        window.deselectAllCountries = deselectAllCountries;
        window.updateVisualization = updateVisualization;
        window.toggleCountryPanel = toggleCountryPanel;

        // Debug: Test tooltip on page load - DISABLED for smooth loading animation
        // Tooltip will be enabled automatically after loading sequence completes
        /*
        setTimeout(() => {
            const tooltip = document.getElementById('customTooltip');
            console.log('Testing tooltip visibility...');
            tooltip.style.display = 'block';
            tooltip.style.position = 'fixed';
            tooltip.style.left = '100px';
            tooltip.style.top = '100px';
            tooltip.style.opacity = '1';
            tooltip.style.zIndex = '99999';
            tooltip.classList.add('show');
            
            setTimeout(() => {
                tooltip.classList.remove('show');
                tooltip.style.display = 'none';
                tooltip.style.opacity = '0';
            }, 2000);
        }, 1000);
        */

        // Debug: Check if points are being rendered
        setTimeout(() => {
            const pointsData = myGlobe.pointsData();
            console.log('Points data:', pointsData);
            console.log('Number of points:', pointsData.length);
            
            // Force re-register hover events
            console.log('Re-registering hover events...');
            myGlobe.onPointHover((point, prevPoint) => {
                const tooltip = document.getElementById('customTooltip');
                console.log('HOVER EVENT:', { point, prevPoint });
                
                if (point && point.name) {
                    console.log('SHOWING tooltip for:', point.name);
                    
                    // Cancel any pending hide timeout
                    showTooltipImmediate();
                    
                    // Force show tooltip first with all necessary styles
                    tooltip.style.display = 'block';
                    tooltip.style.visibility = 'visible';
                    tooltip.style.opacity = '1';
                    tooltip.style.position = 'fixed';
                    tooltip.style.zIndex = '99999';
                    tooltip.style.pointerEvents = 'none';
                    tooltip.style.background = 'rgba(26, 48, 47, 0.98)';
                    tooltip.style.border = '2px solid #86F5AF';
                    tooltip.style.borderRadius = '8px';
                    tooltip.style.padding = '12px 16px';
                    tooltip.style.color = 'white';
                    
                    // Update tooltip content
                    const nameEl = document.getElementById('tooltipName');
                    const countEl = document.getElementById('tooltipCount');
                    const coordsEl = document.getElementById('tooltipCoords');
                    
                    if (nameEl) nameEl.textContent = point.name.toUpperCase();
                    if (countEl) countEl.textContent = `${point.count} SUPERSIDERS`;
                    if (coordsEl) coordsEl.textContent = `Lat: ${point.coordinates.lat.toFixed(2)}°, Lng: ${point.coordinates.lng.toFixed(2)}°`;
                    
                    // Position tooltip following mouse with offset
                    const offsetX = 25;
                    const offsetY = -40;
                    let x = currentMouseX + offsetX;
                    let y = currentMouseY + offsetY;
                    
                    // Keep within bounds
                    if (x + 300 > window.innerWidth) x = currentMouseX - 300 - offsetX;
                    if (y < 0) y = currentMouseY + offsetX;
                    
                    tooltip.style.left = x + 'px';
                    tooltip.style.top = y + 'px';
                    tooltip.style.transform = 'none';
                    
                    // Add the show class
                    tooltip.classList.add('show');
                    
                    console.log('Tooltip styles applied and should be visible');
                } else {
                    console.log('HIDING tooltip with delay');
                    // Hide tooltip with delay instead of immediately
                    hideTooltipDelayed();
                }
            });
        }, 2000);

        // Add click interaction for points
        myGlobe.onPointClick((point, event) => {
            console.log('Clicked country:', point.name, 'Count:', point.count);
            
            // Show country info overlay
            showCountryInfo(point);
            
            // Center the globe on the clicked point
            myGlobe.pointOfView({
                lat: point.coordinates.lat,
                lng: point.coordinates.lng,
                altitude: 1.5
            }, 1000);
        });

        // Add hover interaction for points
        myGlobe.onPointHover((point, prevPoint) => {
            const tooltip = document.getElementById('customTooltip');
            console.log('onPointHover triggered', { point, prevPoint });
            
            if (point && point.name) {
                console.log('SHOWING tooltip for:', point.name);
                
                // Cancel any pending hide timeout
                showTooltipImmediate();
                
                // Force show tooltip first with all necessary styles
                tooltip.style.display = 'block';
                tooltip.style.visibility = 'visible';
                tooltip.style.opacity = '1';
                tooltip.style.position = 'fixed';
                tooltip.style.zIndex = '99999';
                tooltip.style.pointerEvents = 'none';
                tooltip.style.background = 'rgba(26, 48, 47, 0.98)';
                tooltip.style.border = '2px solid #86F5AF';
                tooltip.style.borderRadius = '8px';
                tooltip.style.padding = '12px 16px';
                tooltip.style.color = 'white';
                
                // Update tooltip content
                const nameEl = document.getElementById('tooltipName');
                const countEl = document.getElementById('tooltipCount');
                const coordsEl = document.getElementById('tooltipCoords');
                
                if (nameEl) nameEl.textContent = point.name.toUpperCase();
                if (countEl) countEl.textContent = `${point.count} SUPERSIDERS`;
                if (coordsEl) coordsEl.textContent = `Lat: ${point.coordinates.lat.toFixed(2)}°, Lng: ${point.coordinates.lng.toFixed(2)}°`;
                
                // Position tooltip following mouse with offset
                const offsetX = 25;
                const offsetY = -40;
                let x = currentMouseX + offsetX;
                let y = currentMouseY + offsetY;
                
                // Keep within bounds
                if (x + 300 > window.innerWidth) x = currentMouseX - 300 - offsetX;
                if (y < 0) y = currentMouseY + offsetX;
                
                tooltip.style.left = x + 'px';
                tooltip.style.top = y + 'px';
                tooltip.style.transform = 'none';
                
                // Add the show class
                tooltip.classList.add('show');
                
                console.log('Tooltip styles applied and should be visible');
            } else {
                console.log('HIDING tooltip with delay');
                // Hide tooltip with delay instead of immediately
                hideTooltipDelayed();
            }
        });
        
        // Track mouse position for better tooltip positioning
        let currentMouseX = 0;
        let currentMouseY = 0;
        let isTooltipVisible = false;
        let tooltipTimeout = null; // Add timeout for delayed hiding
        
        // Function to hide tooltip with delay
        function hideTooltipDelayed() {
            if (tooltipTimeout) {
                clearTimeout(tooltipTimeout);
            }
            tooltipTimeout = setTimeout(() => {
                const tooltip = document.getElementById('customTooltip');
                tooltip.classList.remove('show');
                tooltip.style.display = 'none';
                tooltip.style.opacity = '0';
                tooltip.style.visibility = 'hidden';
                console.log('Tooltip hidden after delay');
            }, 1000); // 1 second delay
        }
        
        // Function to show tooltip immediately
        function showTooltipImmediate() {
            if (tooltipTimeout) {
                clearTimeout(tooltipTimeout);
                tooltipTimeout = null;
            }
        }
        
        document.addEventListener('mousemove', (e) => {
            currentMouseX = e.clientX;
            currentMouseY = e.clientY;
            
            const tooltip = document.getElementById('customTooltip');
            if (tooltip && tooltip.classList.contains('show')) {
                // Add some offset to avoid cursor blocking the tooltip
                const offsetX = 25;
                const offsetY = -40;
                
                let x = currentMouseX + offsetX;
                let y = currentMouseY + offsetY;
                
                // Keep tooltip within viewport bounds
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                const tooltipWidth = 300; // estimated width
                const tooltipHeight = 100; // estimated height
                
                if (x + tooltipWidth > viewportWidth) {
                    x = currentMouseX - tooltipWidth - offsetX;
                }
                if (y < 0) {
                    y = currentMouseY + offsetX;
                }
                if (y + tooltipHeight > viewportHeight) {
                    y = currentMouseY - tooltipHeight - offsetX;
                }
                
                tooltip.style.left = x + 'px';
                tooltip.style.top = y + 'px';
            }
        });

        // Alternative hover detection using raycasting
        document.getElementById('globeViz').addEventListener('mousemove', (event) => {
            // This is a backup hover detection method
            console.log('Mouse moving over globe area');
        });

        // Add click interaction for arcs
        myGlobe.onArcClick((arc, event) => {
            console.log('Clicked connection:', arc.startCountry, '↔', arc.endCountry);
            // Center the globe between the two connected countries
            const midLat = (arc.startLat + arc.endLat) / 2;
            const midLng = (arc.startLng + arc.endLng) / 2;
            myGlobe.pointOfView({
                lat: midLat,
                lng: midLng,
                altitude: 2.0
            }, 1000);
        });

        // Add some atmospheric effects
        myGlobe.atmosphereAltitude(0.25);
        myGlobe.atmosphereColor('lightskyblue');

        // Auto-rotate the globe slowly
        myGlobe.controls().autoRotate = true;
        myGlobe.controls().autoRotateSpeed = 0.125; // Reduced from 0.25 to half speed
        
        // Regenerate connections periodically for more dynamic visualization
        setInterval(() => {
            if (enabledCountries.size > 0) {
                connections = generateConnections();
                myGlobe.arcsData(connections);
                console.log('Connections regenerated automatically');
            }
        }, 8000); // Regenerate every 8 seconds (slower regeneration for fewer but more varied connections)
    </script>
</body>
</html>
